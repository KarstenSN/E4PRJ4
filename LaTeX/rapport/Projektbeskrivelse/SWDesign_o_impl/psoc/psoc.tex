\subsection{PSoC} \label{sec:swd_psoc_board}

PSoC'en blev valgt pga. vanskeligheder mht. direkte adgang til timere på Pi og pga. et besværligt interface ifm. \IIC kommunikation. Et positivt resultat af dette er at det PSoC'en håndterer skal ske relativt ofte, og den vil blive afbrudt mange gange i sekundet, hvilket ville langsommeliggøre Pi'en endnu mere. På denne måde løses problemerne med Raspberry Pi's tillukkethed og Pi'en skal kun læse en gang fra PSoC'en for at kunne få den ønskede data. PSoC'en sørger for at holde en buffer klar til at Pi'en,  

%TODO Kenn skriver om distancesensorerne

PSoC'en er sat op så tachometerets output skal tilsluttes til [P1.0], som er sat op til at starte et interrupt hvis der detekteres en nedadgående flanke i spændingen. Selve interrupt routinen gemmer den seneste timerværdi, og aflæser en ny, finder differencen mellem disse og udregner hastigheden som set i afsnittet \ref{P-sec:tachometer_hw_impl}. Når bilen kører maksimalhastighed ca. $10km/t$ betyder dette at der vil være lige under 72 interrupts pr. sekund. Dette kunne potentielt være et problem på Pi'en, da projektet bygger på en pi, som skal være så nær realtid som muligt, for at systemet kan nå at reagere på objekter der nærmer sig hastigt.


%TODO Dette blev copy/pasted ind fra impl /KT
\subsection{PSoC} \label{sec:swi_psoc_board}

Som forventet var PSoC'en mere simpel at implementere, da der allerede er findes foruddefinerede \IIC kommandoer, som gør det væsentligt simplere at kommunikere med sensorerne. Det blev undersøgt på Pi'en hvorledes det var muligt at indføre et kernemodul, som ville tillade at aflæse processorens clockcycles, men det viste sig meget at være meget tidskrævende, og endte ud i spildtid. I første omgang stødte gruppen på et problem ifm. aflæsning af PSoC'en, da tiden som distancesensorerne tager om at aflæses tager en minimumstid, som læsningen af PSoC'en ikke må afbryde, da der ellers kommer korrupte værdier over på Pi'en. 

%TODO Kenn skriver om distancesensorerne